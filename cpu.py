import threading
# The import list has been updated to include all the new and refactored instruction classes.
from instructions import (Instruction, InvalidInstruction, Nop, Hlt, Ret, PushA, PopA, PushF, PopF, Sti,
                          Cli, Iret, IncReg, DecReg, NotReg, StoreInd, LoadInd, Jmp, Call, Jz, Jnz, Jc,
                          Jnc, Jn, Jnn, Load, Store, LoadIx, StoreIx, LoadSp, ShlRegVal8, ShrRegVal8,
                          RolRegVal8, RorRegVal8, Mov, Add, Sub, Cmp, And, Or, Xor, Mul, Div, Push, Pop)

font_data = [
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x00,0x00,
    0x36,0x36,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x5A,0x24,0x7E,0x24,0x5A,0x18,0x00,
    0x44,0x4A,0x52,0x4A,0x48,0x00,0x00,0x00,0x6C,0x54,0x28,0x1A,0x36,0x00,0x00,0x00,
    0x18,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x0C,0x18,0x30,0x60,0x60,0x00,0x00,0x00,
    0x60,0x30,0x18,0x0C,0x0C,0x00,0x00,0x00,0x00,0x36,0xDB,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x3E,0x00,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x30,0x00,
    0x00,0x00,0x00,0x00,0x3E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,
    0x00,0x00,0x00,0x04,0x08,0x10,0x20,0x40,0x00,0x00,0x00,0x3C,0x42,0x42,0x42,0x42,
    0x42,0x3C,0x00,0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00,0x3C,0x42,0x02,0x04,0x08,
    0x10,0x7E,0x00,0x3C,0x42,0x02,0x1C,0x02,0x42,0x3C,0x00,0x04,0x0C,0x14,0x24,0x7E,
    0x04,0x04,0x00,0x7E,0x40,0x40,0x7C,0x02,0x02,0x3C,0x00,0x3C,0x40,0x40,0x7C,0x42,
    0x42,0x3C,0x00,0x40,0x40,0x20,0x10,0x08,0x08,0x08,0x00,0x3C,0x42,0x42,0x3C,0x42,
    0x42,0x3C,0x00,0x3C,0x42,0x42,0x3E,0x02,0x02,0x3C,0x00,0x00,0x00,0x18,0x18,0x00,
    0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x18,0x18,0x30,0x04,0x08,0x10,0x20,0x10,
    0x08,0x04,0x00,0x00,0x3E,0x00,0x3E,0x00,0x3E,0x00,0x00,0x20,0x10,0x08,0x04,0x08,
    0x10,0x20,0x00,0x3C,0x42,0x02,0x0C,0x18,0x00,0x18,0x00,0x3C,0x42,0x4A,0x4A,0x4A,
    0x40,0x3C,0x00,0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00,0x7C,0x66,0x66,0x7C,0x66,
    0x66,0x7C,0x00,0x3C,0x66,0x40,0x40,0x40,0x66,0x3C,0x00,0x7C,0x66,0x66,0x66,0x66,
    0x66,0x7C,0x00,0x7E,0x40,0x40,0x7C,0x40,0x40,0x7E,0x00,0x7E,0x40,0x40,0x7C,0x40,
    0x40,0x40,0x00,0x3C,0x66,0x40,0x40,0x4E,0x66,0x3C,0x00,0x66,0x66,0x66,0x7E,0x66,
    0x66,0x66,0x00,0x7E,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x02,0x02,0x02,0x02,0x62,
    0x66,0x3C,0x00,0x66,0x6C,0x78,0x70,0x6C,0x66,0x66,0x00,0x40,0x40,0x40,0x40,0x40,
    0x40,0x7E,0x00,0x66,0x66,0x7E,0x7E,0x76,0x66,0x66,0x00,0x66,0x66,0x76,0x7E,0x6E,
    0x66,0x66,0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x7C,0x66,0x66,0x7C,0x40,
    0x40,0x40,0x00,0x3C,0x66,0x66,0x66,0x6E,0x6C,0x3E,0x00,0x7C,0x66,0x66,0x7C,0x6C,
    0x66,0x66,0x00,0x3C,0x60,0x3C,0x06,0x3C,0x00,0x00,0x00,0x7E,0x18,0x18,0x18,0x18,
    0x18,0x18,0x00,0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00,0x66,0x66,0x3C,0x18,0x3C,
    0x66,0x66,0x00,0x66,0x66,0x66,0x3C,0x66,0x66,0x66,0x00,0x66,0x3C,0x18,0x3C,0x66,
    0x00,0x00,0x00,0x66,0x3C,0x18,0x18,0x18,0x00,0x00,0x00,0x7E,0x02,0x04,0x08,0x7E,
    0x00,0x00,0x00,0x7E,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x40,0x20,0x10,0x08,0x04,
    0x00,0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x3C,0x66,0x00,0x00,
    0x00,0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x30,0x18,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x3C,0x06,0x3E,0x66,0x66,0x3E,0x00,0x40,0x40,0x7C,0x66,0x66,
    0x66,0x7C,0x00,0x00,0x00,0x3C,0x60,0x60,0x60,0x3C,0x00,0x06,0x06,0x3E,0x66,0x66,
    0x66,0x3E,0x00,0x00,0x3C,0x66,0x7E,0x60,0x60,0x3C,0x00,0x1C,0x30,0x78,0x30,0x30,
    0x30,0x30,0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x66,0x3E,0x40,0x40,0x7C,0x66,0x66,
    0x66,0x66,0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x3C,0x00,0x04,0x04,0x04,0x04,0x64,
    0x64,0x38,0x00,0x40,0x40,0x60,0x70,0x6C,0x66,0x66,0x00,0x38,0x18,0x18,0x18,0x18,
    0x18,0x18,0x00,0x00,0x00,0x7C,0x66,0x76,0x66,0x66,0x00,0x00,0x00,0x7C,0x66,0x66,
    0x66,0x66,0x00,0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00,0x00,0x7C,0x66,0x66,0x7C,
    0x40,0x40,0x40,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06,0x06,0x00,0x00,0x7C,0x66,0x40,
    0x40,0x40,0x00,0x00,0x00,0x3E,0x06,0x3C,0x60,0x3E,0x00,0x38,0x18,0x18,0x78,0x18,
    0x18,0x18,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x66,0x66,0x3C,
    0x18,0x18,0x00,0x00,0x00,0x66,0x66,0x76,0x7E,0x66,0x00,0x00,0x00,0x66,0x3C,0x18,
    0x3C,0x66,0x00,0x00,0x00,0x66,0x3C,0x18,0x3C,0x18,0x00,0x00,0x00,0x7E,0x04,0x08,
    0x10,0x7E,0x00,0x0C,0x18,0x18,0x7E,0x18,0x18,0x0C,0x00,0x18,0x18,0x18,0x18,0x18,
    0x18,0x18,0x00,0x30,0x18,0x18,0x7E,0x18,0x18,0x30,0x00,0x00,0x76,0xDB,0x00,0x00,
    0x00,0x00,0x00]

class CPU:
    def __init__( self, memory_size, stack_size, gui=None, update_callback=None ):
        self.memory_size = memory_size
        self.stack_size = stack_size
        self.memory = bytearray( self.memory_size )

        self.registers = { "PC": 0, "SP": self.memory_size }
        for i in range( 10 ):
            self.registers[ f"R{i}" ] = 0
        self.flags = { 'Z': 0, 'C': 0, 'N': 0, 'V': 0, 'A': 0, 'I': 0 }
        self.halted = False

        self.screen_width = 100
        self.screen_height = 100
        self.screen_size = self.screen_width * self.screen_height
        self.stack_base = self.memory_size
        self.stack_limit = self.memory_size - self.stack_size
        self.screen_address = self.stack_limit - self.screen_size
        self.keyboard_data_address = self.screen_address - 1
        self.keyboard_status_address = self.screen_address - 2
        self.font_addr = self.keyboard_status_address - 760
        self.mem_used = ( 760 + 1 + 1 + self.screen_size + self.stack_size )
        self.mem_free = self.memory_size - self.mem_used
        
        # **Font data is now loaded directly into memory on CPU initialization.**
        self.memory[self.font_addr : self.font_addr + len(font_data)] = font_data

        self.running = False
        self.stop_event = threading.Event()
        self.gui = gui
        self.update_callback = update_callback

        self.register_names = { 0x10 + i: f"R{i}" for i in range( 10 ) }
        self.register_pair_names = { 0xA0: ( "R0", "R1" ), 0xA2: ( "R2", "R3" ), 0xA4: ( "R4", "R5" ), 0xA6: ( "R6", "R7" ), 0xA8: ( "R8", "R9" ) }

        self.interrupt_requests = { 'KEYBOARD': False }
        self.interrupt_vector_table = { 'KEYBOARD': 0x0100 }

        self.instruction_set = [ InvalidInstruction() ] * 256

        single_opcode_instrs = [
            Nop(), Hlt(), Ret(), PushA(), PopA(), PushF(), PopF(), Sti(), Cli(), Iret(),
            IncReg(), DecReg(), NotReg(), StoreInd(), LoadInd(), Jmp(), Call(), Jz(), Jnz(),
            Jc(), Jnc(), Jn(), Jnn(), Load(), Store(), LoadIx(), StoreIx(), LoadSp(),
            ShlRegVal8(), ShrRegVal8(), RolRegVal8(), RorRegVal8()
        ]
        for instr in single_opcode_instrs:
            self.instruction_set[instr.opcode] = instr

        merged_opcodes = {
            Mov(): [0x03, 0x08, 0x51],
            Add(): [0x04, 0x09, 0x52, 0x58],
            Sub(): [0x05, 0x0A, 0x59, 0x5A],
            Cmp(): [0x0E, 0x0F, 0x5B, 0x5C],
            And(): [0x40, 0x44, 0x68, 0x69],
            Or(): [0x41, 0x45, 0x6A, 0x6B],
            Xor(): [0x42, 0x46, 0x6C, 0x6D],
            Mul(): [0x50, 0x6E],
            Div(): [0x64, 0x6F],
            Push(): [0x20, 0x62],
            Pop(): [0x21, 0x63],
        }
        for instr, opcodes in merged_opcodes.items():
            for opcode in opcodes:
                self.instruction_set[opcode] = instr

    def _set_flags( self, result, is_16bit=False, v1=0, v2=0, is_sub=False ):
        mask = 0xFFFF if is_16bit else 0xFF
        sign_bit = 0x8000 if is_16bit else 0x80
        self.flags[ 'Z' ] = 1 if ( result & mask ) == 0 else 0
        self.flags[ 'N' ] = 1 if ( result & sign_bit ) else 0
        op2 = -v2 if is_sub else v2
        if ( v1 & sign_bit ) == ( op2 & sign_bit ) and ( v1 & sign_bit ) != ( result & sign_bit ): self.flags[ 'V' ] = 1
        else: self.flags[ 'V' ] = 0
        if is_sub:
            self.flags[ 'A' ] = 1 if ( v1 & 0x0F ) < ( v2 & 0x0F ) else 0
        else:
            self.flags[ 'A' ] = 1 if ( ( v1 & 0x0F ) + ( v2 & 0x0F ) ) > 0x0F else 0

    def _set_carry( self, val ):
        self.flags[ 'C' ] = 1 if val else 0

    def _pack_flags( self ):
        return ( self.flags[ 'Z' ] << 7 ) | ( self.flags[ 'N' ] << 6 ) | ( self.flags[ 'C' ] << 5 ) | ( self.flags[ 'V' ] << 4 ) | ( self.flags[ 'A' ] << 3 ) | ( self.flags[ 'I' ] << 2 )

    def _unpack_flags( self, byte ):
        self.flags[ 'Z' ] = ( byte >> 7 ) & 1
        self.flags[ 'N' ] = ( byte >> 6 ) & 1
        self.flags[ 'C' ] = ( byte >> 5 ) & 1
        self.flags[ 'V' ] = ( byte >> 4 ) & 1
        self.flags[ 'A' ] = ( byte >> 3 ) & 1
        self.flags[ 'I' ] = ( byte >> 2 ) & 1

    def _check_stack_op( self, size, is_push ):
        new_sp = self.registers[ 'SP' ] - size if is_push else self.registers[ 'SP' ] + size
        if not ( self.stack_limit <= new_sp <= self.stack_base ):
            print( f"Stack {'Overflow' if is_push else 'Underflow'} Error. Halting." )
            self.running = False
            return False
        return True
        
    def load_program( self, program_code, start_address ):
        if start_address + len( program_code ) > len( self.memory ):
            print( f"Error: Program is too large. Size: {len( program_code )}")
            return False
        self.memory[ start_address:start_address + len( program_code ) ] = program_code
        return True
    
    def execute_instruction( self ):
        pc = self.registers[ "PC" ]
        opcode = self.memory[ pc ]
        instruction_to_execute = self.instruction_set[ opcode ]
        
        try:
            pc_increment = instruction_to_execute.execute( self )
            if self.running and pc_increment > 0:
                self.registers[ "PC" ] = ( pc + pc_increment ) & 0xFFFF
        except ( TypeError, IndexError, KeyError, ValueError ) as e:
            print( f"CRITICAL CPU ERROR at PC=0x{pc:04X} (Op: 0x{opcode:02X}): {e}" );
            import traceback
            traceback.print_exc();
            self.running = False

    def handle_interrupts( self ):
        if not self.flags[ 'I' ] or not self.interrupt_requests[ 'KEYBOARD' ]: return False
        self.halted = False
        self.interrupt_requests[ 'KEYBOARD' ] = False
        self._check_stack_op( 3, True )
        current_pc = self.registers[ 'PC' ]
        self.registers[ 'SP' ] -= 3
        self.memory[ self.registers[ 'SP' ] ] = self._pack_flags()
        self.memory[ self.registers[ 'SP' ] + 1 ] = ( current_pc >> 8 ) & 0xFF
        self.memory[ self.registers[ 'SP' ] + 2 ] = current_pc & 0xFF
        self.flags[ 'I' ] = 0
        self.registers[ 'PC' ] = self.interrupt_vector_table[ 'KEYBOARD' ]
        return True

    def run( self ):
        self.running = True
        self.halted = False
        self.stop_event.clear()
        while self.running:
            if self.stop_event.is_set():
                self.running = False
                break
            if self.halted:
                self.running = False
                continue

            pc_before = self.registers[ "PC" ]
            if not ( 0 <= pc_before < self.memory_size ):
                print( f"PC Error (0x{pc_before:04X}). Halting." )
                self.running = False
                break

            if not self.handle_interrupts():
                self.execute_instruction()

        print( f"CPU execution finished. Final PC: 0x{self.registers[ 'PC' ]:04X}." )
        if self.update_callback:
            self.update_callback()

    def get_stack_as_string( self, max_entries=8 ):
        stack_str = f"--- Stack Top (SP=0x{self.registers[ 'SP' ]:04X}) ---\n"; count = 0
        start_addr = self.registers[ 'SP' ]; end_addr = min( self.stack_base, start_addr + max_entries )
        if start_addr >= self.stack_base: stack_str += "(SP at/above base)\n"
        for addr in range( start_addr, end_addr ):
             if addr < self.stack_limit:
                continue
             val = self.memory[ addr ]
             marker = "<-- SP" if addr == start_addr else ""
             stack_str += f"[0x{addr:04X}]: 0x{val:02X} {marker}\n"
             count += 1
        if count == 0 and start_addr < self.stack_base : stack_str += "(Empty or SP below range shown)\n"
        return stack_str
    def get_memory_as_string( self, start_address, num_bytes, bytes_per_line=8 ):
        start = max( 0, start_address ); end = min( start + num_bytes, len( self.memory ) )
        mem_str = f"--- Mem Dump: 0x{start:04X}-0x{end-1:04X} ---\n"
        line = ""
        for i in range( start, end ):
            if i % bytes_per_line == 0:
                if line:
                    mem_str += line + "\n"
                line = f"0x{i:04X}: "
            line += f"{self.memory[i]:02X} "
        if line: mem_str += line.rstrip()
        return mem_str